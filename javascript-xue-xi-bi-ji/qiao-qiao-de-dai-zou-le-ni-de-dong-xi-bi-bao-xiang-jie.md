# 悄悄的带走了你的东西——闭包详解

### 闭包的实现原理和作用

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。

#### 闭包：

> 当内部函数被保存到外部时会产生闭包。闭包会导致原有作用域链不释放,造成内存泄漏。

#### 闭包的作用：

* 实现公有变量 => 累加器
* 可以做缓存,存储结构
* 可以实现封装,属性私有化
* 模块化开发,防止污染全局变量

#### 如何快速判断闭包：

* 三个特点：
  * 闭包一定具有嵌套函数
  * 内层函数一定操作了外层函数的局部变量
  * 外层函数,将内层函数返回到外部,变量接住(全局变量)

### 闭包使用的优缺点

* 优点：
  * 1.保护函数内部变量的安全，加强了封装性
  * 2.在内存中维持一个变量
  * 3.设计私有方法和变量
  * 4.可以读取函数内部的变量
* 缺点：
  * 1.导致内存泄漏，使用不当会造成额外的内存占用
  * 2.可以改变父函数的变量，所以使用时要谨慎

#### 闭包的执行结果

* 外层函数被调用几次,就有几个受保护的局部变量副本
* 来自一个闭包的函数被调用几次,受保护的局部变量就变化几次

```
/** 累加器*/
function add() {
  var count = 0
  function demo() {
    count++
    console.log(count)
  }
  return demo
}

var counter = add()
counter()
```

### 理解堆栈溢出和内存泄漏的原理,如何防止

内存泄漏(memory leak)的堆积最终会导致内存溢出(out of memory)

#### 内存泄漏 memory leak

是指程序在\*\*申请内存后,无法释放已申请的内存空间,\*\*一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。

#### 内存溢出 out of memory

指程序申请内存时,\*\*没有足够的内存供申请者使用,\*\*或者说,给了你一块存储 int 类型数据的存储空间,但是你却存储 long 类型的数据,那么结果就是内存不够用,此时就会报错,即所谓的内存溢出。

#### 二者的关系

内存泄漏的堆积最终会导致内存溢出。

#### 内存溢出的原因

1. 内存中**加载的数据量过于庞大**,如一次从数据库取出过多的数据。
2. 集合类中**有对对象的引用,使用完后未清空**,使得 JVM 不能回首。
3. 代码中存在**死循环**或循环产生过多重复的对象实体。
4. 使用的第三方软件中的 BUG。
5. **启动参数内存值设定过小**

#### 内存溢出的解决方案

> 第一步,修改 JVM 启动参数,直接增加内存。(-Xms,-Xmx 参数一定不要忘记加。) 第二步,检查错误日志,查看“OutOfMemory”错误前是否有其 它异常或错误。 第三步,对代码进行走查和分析,找出可能发生内存溢出的位置。
>
> * 重点排查以下几点：
>   * 1.检查对数据库查询中,是否有一次获得全部数据的查询。 一般来说,如果一次取十万条记录到内存,就可能引起内存溢出。 这个问题比较隐蔽,在上线前,数据库中数据较少,不容易出问题,上线后,数据库中数据多了, 一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
>   * 2.检查代码中是否有死循环或递归调用。
>   * 3.检查是否有大循环重复产生新对象实体。
>   * 4.检查 List、MAP 等集合对象是否有使用完后,未清除的问题。 List、MAP 等集合对象会始终存有对对象的引用,使得这些对象不能被 GC 回收。 第四步,使用内存查看工具动态查看内存使用情况

### 如何处理循环的异步操作

**如何确保循环的所有异步操作完成之后执行某个其他操作**

```
/**设置一个flag,在每个一步操作中对flag进行检测*/
let flag = 0
for (let i = 0; i < len; i++) {
  flag++
  Database.save_method()
    .exec()
    .then((data) => {
      if (flag === len) {
        // your code
      }
    })
}
/**将所有的循环放在一个promise中,使用then处理*/
new Promise(function(resolve) {
  resolve()
})
  .then(() => {
    for (let i = 0; i < len; i++) {
      Database.save_method().exec()
    }
  })
  .then(() => {
    // your code
  })
```

**循环中的下一步操作依赖于前一步的操作**

```
/**使用递归,再异步操作完成之后调用下一步异步操作*/
function loop(i) {
  i++
  Database.save_method()
    .exec()
    .then(() => {
      loop(i)
    })
}
/**使用 async 和 await */
async function loop() {
  for (let i = 0; i < len; i++) {
    await Database.save_method().exec()
  }
}
```
