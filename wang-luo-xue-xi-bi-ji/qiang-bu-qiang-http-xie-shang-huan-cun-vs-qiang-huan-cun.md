# 强不强——HTTP-协商缓存VS强缓存

## HTTP-协商缓存VS强缓存

缓存的作用不言而喻，能够极大的改善网页性能，提高用户体验

### 浏览器缓存

当第一次请求数据时，通过返回的响应头告诉浏览器如何缓存资源，可能采用的是强缓存，也可能告诉浏览器是协商缓存。

当浏览器在请求资源时，回显获取到该资源缓存的header信息，判断是否是强缓存，如果命中直接从缓存中获取资源信息，本次请求不会和服务器之间通信。

### 强缓存

第一次访问服务器取到数据之后，在过期时间内不会再次去重复请求。

#### HTTP 1.0 (Expires)

在 HTTP 1.0 版本中，强缓存通过 **Expires** 响应头来实现。**Expires** 表示未来资源会过期的时间。当发起请求的时间超过了 **Expires** 设定的时间，则表示资源缓存到期，会发送请求到服务器重新获取资源。如果发送请求时间在**Expires**限定时间内，浏览器会直接读取本地缓存数据库中的信息。

#### HTTP 1.1 (Cache-Control)

在 HTTP 1.1 版本中，强缓存通过 **Cache-Control** 响应头来实现

* private 客户端可以缓存，服务器不能缓存
* public 客户端和代理服务器均可缓存
* **max-age 缓存的资源将在设定时间后过期**
* no-cache 不使用本地缓存，使用协商缓存
* no-store 直接禁止浏览器缓存数据

> 如果 Cache-Control 与 Expires 同时存在的话，Cache-Control 的优先级较高

#### 总结

**强制缓存只有在首次请求才会和服务器通信，读取缓存资源时不会发出任何请求，资源的状态码为200，HTTP 1.1 版本的实现优先级会高于 HTTP 1.0 版本的实现**

### 协商缓存

首先协商缓存在每次读取数据时都会和服务器通信，并且会增加缓存标识。在第一次请求资源时，服务器会返回资源，并且返回一个资源缓存标识，当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后会进行匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识返回到客户端，如果标识匹配，表示资源没有更新，并且返回 **304** 状态码，浏览器就读取本地缓存数据

#### HTTP 1.0 (Last-Modified/If-Modified-Since)

在 HTTP 1.0 版本中，第一次请求资源时服务器通过 **Last-Modified** 来设置响应头缓存标识，并且把资源最后修改的时间作为值填入，然后将资源返回给浏览器。第二次请求时，浏览器会带上 **IF-Modified-Since** 请求头去访问服务器，服务器会将 **If-Modified-Since** 中携带的时间尽心匹配，如果不一致，服务器返回新的资源，并且将**Last-Modified** 值更新，作为响应头返回浏览器。如果时间一致，表示资源没有更新，服务器返回 304 状态码，浏览器取本地缓存数据。

#### HTTP 1.1 (Etag/If-None-Match)

在 HTTP 1.1 版本中，服务器通过 **Etag** 来设置响应头缓存标识。 **Etag** 的值有服务端生成。第一次请求时，服务器会将资源和 **Etag** 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。在第二次请求时，浏览器会将 **Etag** 信息放在 **If-None-Match** 请求头去访问服务器，服务器收到请求后，会将服务器中的标识进行比对，如果不相同，服务器返回更新的资源和新的 **Etag**，如果相同，服务器返回 304 状态码，浏览器读取缓存。

#### 总结

协商缓存每次请求都会与服务器交互，第一次是拿数据和标识，第二次开始就是浏览器询问服务器是否更新的过程。每次请求都会传输数据，如果命中缓存，资源状态码为 304，HTTP 1.1 版本的实现优先级会高于 HTTP 1.0 版本的实现
